import java.util.concurrent.ForkJoinPool
import java.util.concurrent.RecursiveAction

Map<String, Project> compositeProjects = new HashMap<String, Project>()
Map<String, String> includedProjects = new HashMap<String, String>()

class Project {
    def settingsGradleFile
    def buildGradleFile
    def groupId
    def artifactId

    Project(File settingsFile) {
        this.settingsGradleFile = settingsFile
        this.buildGradleFile = new File(settingsFile.path.replace("settings", "build"))
    }

    Project(String path) {
        this.buildGradleFile = new File("$path/build.gradle")
        if (!this.buildGradleFile.exists()) {
            this.buildGradleFile = new File("$path/build.gradle.kts")
        }
    }
}

class ForkJoinFileProcessor extends RecursiveAction {

    static String rootDir
    static Map<String, String> includedProjects
    static final int MAX_FILE_PER_THREAD = 50

    Map<String, Project> compositeProjects

    ForkJoinFileProcessor(Map<String, Project> compositeProjects, String rootDir, Map<String, String> includedProjects) {
        this.compositeProjects = compositeProjects
        this.rootDir = rootDir
        this.includedProjects = includedProjects
    }

    ForkJoinFileProcessor(Map<String, Project> compositeProjects) {
        this.compositeProjects = compositeProjects
    }

    @Override
    protected void compute() {
        if (compositeProjects.size() > MAX_FILE_PER_THREAD) {
            createSubTasks()
        } else {
            processFile()
        }
    }

    void createSubTasks() {
        ForkJoinFileProcessor leftTask
        ForkJoinFileProcessor rightTask

        Map<String, Project> left = new HashMap<String, Project>()
        Map<String, Project> right = new HashMap<String, Project>()

        Iterator iterator = compositeProjects.entrySet().iterator()
        while (iterator.hasNext()) {
            def pair = iterator.next()
            if (left.size() < iterator.size() / 2) {
                left.put(pair.key, pair.value)
            } else {
                right.put(pair.key, pair.value)
            }

            if (left.size() == iterator.size() / 2 && leftTask == null) {
                leftTask = new ForkJoinFileProcessor(left)
                leftTask.fork()
            }
            if (!iterator.hasNext()) {
                rightTask = new ForkJoinFileProcessor(right)
                rightTask.fork()
            }

            if (leftTask != null) leftTask.join()
            if (rightTask != null) rightTask.join()
        }
    }

    void processFile() {
        def iterator = compositeProjects.entrySet().iterator()
        while (iterator.hasNext()) {
            def compositeProject = iterator.next()
            if (rootDir.toString() != compositeProject.key.toString()) {
                compositeProject.value.settingsGradleFile.eachLine { line ->
                    if (line.startsWith("include") && !line.startsWith("includeBuild")) {
                        String[] tempString = line.split("[\'\"]")
                        for (int i = 1; i < tempString.size(); i += 2) {
                            includedProjects.put(tempString[i],
                                    "${compositeProject.key}${tempString[i].replace(":", "/")}")
                        }
                    } else if (line.contains("projectDir")) {
                        String[] tempString = line.split("[\'\"]")
                        // we already get it's relative path (Ex: ../../xxProject or /a/b/c/xxProject)
                        // we need to get it's absolute path (Ex: /Users/nakama/ProjectA/xxProject)
                        def relativePath = tempString[3].split("/")
                        def absolutePath = compositeProject.key.split("/").toList()

                        relativePath.each {
                            if (it == "..") {
                                absolutePath.removeLast()
                            } else if (!it.empty) {
                                absolutePath.add(it)
                            }
                        }

                        includedProjects.put(tempString[1], absolutePath.join("/"))
                    }
                }
            }
        }

        // add the included projects to composite project list if not present
        includedProjects.entrySet().each {
            if (!compositeProjects.containsKey(it.value)) {
                def settingsGradleFile = new File("${it.value}/settings.gradle")
                if (!settingsGradleFile.exists()) {
                    settingsGradleFile = new File("${it.value}/settings.gradle.kts")
                }
                if (settingsGradleFile.exists()) {
                    compositeProjects.putIfAbsent(it.value, new Project(settingsGradleFile))
                } else {
                    compositeProjects.putIfAbsent(it.value, new Project(it.value.toString()))
                }
            }
        }

        // now we need to read each project build.gradle file in order to get it's groupId and artifactId
        compositeProjects.each { project ->
            if (rootDir.toString() != project.key.toString()) {
                project.value.buildGradleFile.eachLine {
                    if (it.trim().startsWith("groupId")) {
                        project.value.groupId = it.split("[\'\"]")[1]
                    } else if (it.trim().startsWith("artifactId")) {
                        project.value.artifactId = it.split("[\'\"]")[1]
                    }
                }
            }
        }
    }
}

if (new File("$rootDir/.compositeScan-enable").exists()) {
    gradle.ext.compositeProjects = new ArrayList<String>()
    // get all setting files
    def scanningStartTime = System.nanoTime()
    def settingFileTree = fileTree(dir: rootDir, include: ['**/settings.gradle', '**/settings.gradle.kts', '**/build.gradle', '**/build.gradle.kts'])
    settingFileTree.each {
        compositeProjects.putIfAbsent(it.path.replaceAll("/settings.gradle|/build.gradle|.kts", ""), new Project(it))
    }
    def scanningEndTime = System.nanoTime()

    def processingCompositeStartTime = System.nanoTime()
    ForkJoinPool forkJoinPool = new ForkJoinPool()
    forkJoinPool.invoke(new ForkJoinFileProcessor(compositeProjects, rootDir.path, includedProjects))
    def processingCompositeEndTime = System.nanoTime()

    def iterator = compositeProjects.entrySet().iterator()

    def substitutingStartTime = System.nanoTime()
    while (iterator.hasNext()) {
        def pair = iterator.next()
        if (pair.key != rootDir.toString()) {
            if (!gradle.ext.compositeProjects.contains(pair.key.toString())) {
                gradle.ext.compositeProjects.add(pair.key.toString())
            }
            if (new File("${pair.key}/.composite-enable").exists()) {
                includeBuild(pair.key) {
                    if (pair.value.artifactId != null && pair.value.groupId != null) {
                        dependencySubstitution {
                            substitute module("${pair.value.groupId}:${pair.value.artifactId}") with project(":")
                        }
                    }
                }
            }
        }
    }
    def substitutingEndTime = System.nanoTime()

    def scanningDiffTime = (scanningEndTime - scanningStartTime)
    def processingCompositeDiffTime = (processingCompositeEndTime - processingCompositeStartTime)
    def substitutingDiffTime = (substitutingEndTime - substitutingStartTime)

    println "Scanning projects takes ${scanningDiffTime} ns or ${scanningDiffTime / 1000000} ms"
    println "Processing projects takes ${processingCompositeDiffTime} ns or ${processingCompositeDiffTime / 1000000} ms"
    println "Substituting projects takes ${substitutingDiffTime} ns or ${substitutingDiffTime / 1000000} ms"
}